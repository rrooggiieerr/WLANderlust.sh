#!/bin/bash
#
# WLANderlust
#
# Rogier van Staveren, January 2018, initial release

# Are we root?
[ "$(id -u)" -eq 0 ] &&
	ROOT='true' ||
	ROOT='false'

usage()
{
	if $ROOT; then
		echo -e '\x1B[1mWLANderlust
\x1B[2mNot all those who WLANder have lost connection\x1B[0m

Usage:
  -h, --help
  -i, --interface [interface]
  -s, --solve
  --startIPoverDNS	Starts IP over DNS tunneling if Captive Portal could not be solved
  --stopIPoverDNS	Stops IP over DNS tunneling
  --force		Forces IP over DNS tunneling if connection is not obstructed
  --startVPN		Starts VPN if IP over DNS tunnel is not active
  --VPNtype [type]	Sets the type of VPN to use
  --stopVPN		Stops VPN
  --startFirewall
  --stopFirewall
  --restartFirewall
  --reassociate
  --switchHostAPchannel
  --append2WPAsupplicant
  --status
  --verbose
  --debug'
  	else
	  	echo -e '\x1B[1mWLANderlust
\x1B[2mNot all those who WLANder have lost connection\x1B[0m

Usage:
  -h, --help
  -i, --interface [interface]
  -s, --solve
  --status
  --verbose
  --debug

Run as root for more options'
	fi
}

SCRIPTNAME="$0"

logMessage()
{
	[[ -t 1 || -p /dev/stdin ]] &&
		echo "$@"
	[ ! -z "$LOGFILE" ] && [ "$LOGFILE" != '/dev/stdout' ] &&
		echo "`date` $INTERFACE $SCRIPTNAME $@" >> "$LOGFILE"
}

logError()
{
	[[ -t 1 || -p /dev/stdin ]] &&
		# Set text color to bold red
		echo -e "\x1B[1m\x1B[31m$@\x1B[0m" > /dev/stderr
	[ ! -z "$LOGFILE" ] && [ "$LOGFILE" != '/dev/stdout' ] &&
		echo "`date` $INTERFACE $SCRIPTNAME $@" >> "$LOGFILE"
}

# macOS compatibility
if ! which realpath > /dev/null; then
	realpath() {
		[[ $1 = /* ]] && echo "$1" || echo "$PWD/${1#./}"
	}
fi
if ! which md5sum > /dev/null; then
	md5sum() {
		[ -z "$1" ] &&
			md5 ||
			md5 "$1"
	}
fi


MYDIR="${BASH_SOURCE%/*}"
[[ ! -d "$MYDIR" ]] && MYDIR="$PWD"

# Are we root?
[ "$(id -u)" -eq 0 ] &&
	ROOT='true' ||
	ROOT='false'

# Some default settings
DEFAULTCONFIGPATH='/etc/WLANderlust'
! $ROOT && DEFAULTCONFIGPATH=~/
[ -z "$CONFIGPATH" ] && CONFIGPATH="$DEFAULTCONFIGPATH"
DEFAULTCONFIGFILE="$CONFIGPATH/WLANderlust.conf"
! $ROOT && DEFAULTCONFIGFILE=~/'.WLANderlust.conf'
[ -z "$CONFIGFILE" ] && CONFIGFILE="$DEFAULTCONFIGFILE"

DEFAULTLOGPATH='/var/log'
! $ROOT && DEFAULTLOGPATH=~/
DEFAULTLIBPATH="$(realpath "$MYDIR/../lib/WLANderlust/")"

DEFAULTCONFIG="LOGPATH='$DEFAULTLOGPATH'
LIBPATH='$DEFAULTLIBPATH'
COOKIEJAR=''
LOGFILE=''
GPSFILE=''

AUTOSWITCHHOSTAPCHANNEL='false'
AUTOREASSOCIATE='false

VERBOSELOGGING='false'
DEBUGLOGGING='false'
SHOWPASSWORDS='false'

TIMEOUT='5'

WHATISMYIPURL='https://api.ipify.org'"

readConfig()
{
	# Load the WLANderlust configuration file
	[ -z "$CONFIG" ] && [ -f "$CONFIGFILE" ] &&
		CONFIG=`cat "$CONFIGFILE"`
}

# $1 key
# $2 default value
getConfigValue()
{
	readConfig

	# Lookup key value in the configuration
	VALUE=`sed -n "s|^$1=['\"]\{0,1\}\([^'\"]*\)['\"]\{0,1\}$|\1|p" <<< "$CONFIG" | tail -n 1`
	# If value is empty lookup the key value in the default configuration
	[ -z "$VALUE" ] && VALUE=`sed -n "s|^$1=['\"]\{0,1\}\([^'\"]*\)['\"]\{0,1\}$|\1|p" <<< "$DEFAULTCONFIG" | tail -n 1`
	# If value is empty use the default value
	[ -z "$VALUE" ] && VALUE="$2"

	echo "$VALUE"
}

# $1 key
# $2 value
setConfigValue()
{
	readConfig

	# Check if configuration key is already set
	if grep -q "^$1=" <<< "$CONFIG"; then
		# If configuration key is set, update value
		# Escape sed special characters
		_KEY=`sed -e 's/[]\/$*.^[]/\\\&/g' <<< "$1"`
		_VALUE=`sed -e 's/[\/&]/\\\&/g' <<< "$2"`
		CONFIG=`sed "s|^\($_KEY\)=.*$|\1='$_VALUE'|" <<< "$CONFIG"`
	else
		# If configuration key is not set, add new key with value
		CONFIG+="
$1='$2'"
	fi
}

storeConfig()
{
	[ -z "$CONFIG" ] &&
		return

	# Check if new the configuration changes from the old configuration by comparing the MD5 sums
	OLDMD5=`md5sum "$CONFIGFILE" | awk '{ print $1 }'`
	NEWMD5=`md5sum <<< "$CONFIG"`
	if [ "$OLDMD5" != "$NEWMD5" ]; then
		if touch "$CONFIGFILE"; then
			# The MD5 sum differences, we're dealing with a new configuration, update the configuration
			# Backup previous configuration
			mv "$CONFIGFILE" "$CONFIGFILE.old`date +%Y%m%d%H%M%S`"
			# Store new configuration
			echo "$CONFIG" > "$CONFIGFILE"
		else
			logError "Can't write to configuration file" #'
		fi
	fi
}

DEFAULTCOOKIEJAR="$CONFIGPATH/WLANderlust.cookiejar"
if ! $ROOT; then
	DEFAULTCOOKIEJAR=~/'.WLANderlust.cookiejar'
fi

[ -z "$LOGPATH" ] && LOGPATH=`getConfigValue 'LOGPATH'`
DEFAULTLOGFILE="$LOGPATH/WLANderlust.log"
DEFAULTGPSFILE="$LOGPATH/WLANderlust.gps"

[ -z "$LIBPATH" ] && LIBPATH=`getConfigValue 'LIBPATH'`

[ -z "$COOKIEJAR" ] && COOKIEJAR=`getConfigValue 'COOKIEJAR' "$DEFAULTCOOKIEJAR"`
[ -z "$LOGFILE" ] && LOGFILE=`getConfigValue 'LOGFILE' "$DEFAULTLOGFILE"`
[ ! -w "$LOGFILE" ] && [ ! -w `dirname "$LOGFILE"` ] && LOGFILE='/dev/stdout'
[ -z "$GPSFILE" ] && GPSFILE=`getConfigValue 'GPSFILE' "$DEFAULTGPSFILE"`
([ ! -w "$GPSFILE" ] || ([ ! -f "$GPSFILE" ] && [ ! -w `dirname "$GPSFILE"` ])) && GPSFILE='/dev/null'
[ -z "$DEBUGLOGGING" ] && DEBUGLOGGING=`getConfigValue 'DEBUGLOGGING'`
[ -z "$VERBOSELOGGING" ] && VERBOSELOGGING=`getConfigValue 'VERBOSELOGGING'`
[ -z "$DEBUGLOGGING" ] && DEBUGLOGGING=`getConfigValue 'DEBUGLOGGING'`
[ -z "$TIMEOUT" ] && TIMEOUT=`getConfigValue 'TIMEOUT'`
[ -z "$SHOWPASSWORDS" ] && SHOWPASSWORDS=`getConfigValue 'SHOWPASSWORDS'`

# Are we in interactive mode?
[[ -t 1 || -p /dev/stdin ]] &&
	INTERACTIVE='true' ||
	INTERACTIVE='false'

# Handle arguments
SOLVE='false'
STARTIPOVERDNS='false'
STOPIPOVERDNS='false'
FORCE='false'
STARTVPN='false'
STOPVPN='false'
STARTFIREWALL='false'
STOPFIREWALL='false'
REASSOCIATE='false'
SWITCHHOSTAPCHANNEL='false'
APPEND2WPASUPPLICANT='false'
STATUS='false'
while [ ! -z "$1" ]; do
	PARAM=`tr '[:upper:]' '[:lower:]' <<< "$1"`
	if $ROOT; then
		case $PARAM in
			-h|--help) usage; exit ;;
			-i|--interface) INTERFACE="$2"; shift ;;
			-s|--solve) INTERACTIVE='false'; SOLVE='true' ;;
			--startipoverdns|--startipoverdnstunneling) INTERACTIVE='false'; STARTIPOVERDNS='true' ;;
			--stopipoverdns|--stopIPoverdnstunneling) INTERACTIVE='false'; STOPIPOVERDNS='true' ;;
			--force) FORCE='true' ;;
			--startvpn) INTERACTIVE='false'; STARTVPN='true' ;;
			--vpntype) VPNTYPE="$2"; shift ;;
			--stopvpn) INTERACTIVE='false'; STOPVPN='true' ;;
			--startfirewall) INTERACTIVE='false'; STARTFIREWALL='true' ;;
			--stopfirewall) INTERACTIVE='false'; STOPFIREWALL='true' ;;
			--restartfirewall) INTERACTIVE='false'; STOPFIREWALL='true'; STARTFIREWALL='true' ;;
			--reassociate) INTERACTIVE='false'; REASSOCIATE='true' ;;
			--switchhostapchannel) INTERACTIVE='false'; SWITCHHOSTAPCHANNEL='true' ;;
			--append2wpasupplicant) INTERACTIVE='false'; APPEND2WPASUPPLICANT='true' ;;
			--state|--status) STATUS='true' ;;
			--verbose) VERBOSELOGGING='true' ;;
			--debug) DEBUGLOGGING='true' ;;
			*)
				logError "invalid parameter \"$PARAM\""
				usage
				exit
				;;
		esac
	else
		case $PARAM in
			-h|--help) usage; exit ;;
			-i|--interface) INTERFACE="$2"; shift ;;
			-s|--solve) SOLVE='true' ;;
			--state|--status) STATUS='true' ;;
			--verbose) VERBOSELOGGING='true' ;;
			--debug) DEBUGLOGGING='true' ;;
			*)
				logError "invalid parameter \"$PARAM\""
				usage
				exit
				;;
		esac
	fi
	shift
done

$DEBUGLOGGING && logMessage 'Debug logging enabled'
$VERBOSELOGGING && logMessage 'Verbose logging enabled'
$DEBUGLOGGING && logMessage "Interactive mode: $INTERACTIVE"

TIMESTAMP=`date +%Y%m%d%H%M%S`

# Get the Host AP interface, SSID and channel
if [ -f '/etc/hostapd/hostapd.conf' ]; then
	_HOSTAPDCONF=`cat '/etc/hostapd/hostapd.conf'`
	HOSTAPINTERFACE=`sed -n 's|^interface=\(.*\)$|\1|p' <<< "$_HOSTAPDCONF"`
	HOSTAPSSID=`sed -n 's|^ssid=\(.*\)$|\1|p' <<< "$_HOSTAPDCONF"`

	_IFCONFIG=`ifconfig "$HOSTAPINTERFACE"`
	grep -q '<UP' <<< "$_IFCONFIG" &&
		HOSTAPSTATE='started' ||
		HOSTAPSTATE='stopped'
	HOSTAPIPADDRESS=`sed -n 's|.*inet \([^ ]*\) .*|\1|p' <<< "$_IFCONFIG"`
	HOSTAPNETMASK=`sed -n 's|.*netmask \([^ ]*\) .*|\1|p' <<< "$_IFCONFIG"`

	_IWDEVINFO=`/sbin/iw dev "$HOSTAPINTERFACE" info`
	HOSTAPCHANNEL=`sed -n 's|^.*channel \([0-9]\+\) .*$|\1|p' <<< "$_IWDEVINFO"`
	HOSTAPBSSID=`sed -n 's|^.*addr \([0-9a-f:]\+\)$|\1|p' <<< "$_IWDEVINFO"`
	HOSTAPTXPOWER=`sed -n 's|.*txpower \([0-9.]*\) dBm$|\1|p' <<< "$_IWDEVINFO"`
fi

[ "`uname`" = 'Linux' ] &&
	DEFAULTROUTEINTERFACE=`route -n | sed -n 's|^0\.0\.0\.0 .* \([^ ]*\)$|\1|p' | uniq | sed "/lo/d;/tun[0-9]*/d;/dns[0-9]*/d"`
[ "`uname`" = 'Darwin' ] &&
	DEFAULTROUTEINTERFACE=`netstat -nr | grep '^default' | awk '{ print $6 }'`
# If no interface is given try to figure out which interface to use
if [ -z "$INTERFACE" ] && [ ! -z "$DEFAULTROUTEINTERFACE" ] && [ "$DEFAULTROUTEINTERFACE" != "$HOSTAPINTERFACE" ]; then
	INTERFACE="$DEFAULTROUTEINTERFACE"
	logMessage "No network interface defined, using default route interface $DEFAULTROUTEINTERFACE"
elif [ -z "$INTERFACE" ]; then
	logMessage 'No network interface defined, detecting network interface'
	INTERFACE=`ifconfig | sed -n 's|^\([a-z]*[0-9]*\):.*|\1|p' | sed "/lo/d;/tun[0-9]*/d;/dns[0-9]*/d;/$HOSTAPINTERFACE/d"`
	if [ -z "$INTERFACE" ]; then
		INTERFACE=`ifconfig -a | sed -n 's|^\([a-z]*[0-9]*\):.*|\1|p' | sed "/lo/d;/tun[0-9]*/d;/dns[0-9]*/d;/$HOSTAPINTERFACE/d"`
	fi

	if [ -z "$INTERFACE" ]; then
		logError 'Unable to detect your network interface'
		logError 'Please define a network interface with the --interface [interface] parameter'
		exit 1
	fi

	# Check if only one interface is returned
	if [ "`wc -l <<< "$INTERFACE"`" -gt 1 ]; then
		$DEBUGLOGGING && echo "$INTERFACE"
		logError 'Unable to detect your network interface'
		logError 'Please define a network interface with the --interface [interface] parameter'
		exit 1
	fi
fi

if ! IFCONFIG=`ifconfig "$INTERFACE" 2> /dev/null`; then
	logError "Interface $INTERFACE does not exist"
	exit 1
fi

grep -q '<UP' <<< "$IFCONFIG" &&
	INTERFACEISUP='true' ||
	INTERFACEISUP='false'
$DEBUGLOGGING && $INTERFACEISUP && logMessage "Interface $INTERFACE is up"
$DEBUGLOGGING && ! $INTERFACEISUP && logMessage "Interface $INTERFACE is down"

ISWIFIINTERFACE='false'
[ "`uname`" = 'Linux' ] && grep -q '^wlan[0-9]*$' <<< "$INTERFACE" && ISWIFIINTERFACE='true'
[ "`uname`" = 'Darwin' ]  &&
	networksetup -listallhardwareports | grep -B 1 "^Device: $INTERFACE" | grep -q "Hardware Port: Wi-Fi" &&
	ISWIFIINTERFACE='true'
$VERBOSELOGGING && $ISWIFIINTERFACE && logMessage "Using WiFi interface $INTERFACE"
$VERBOSELOGGING && ! $ISWIFIINTERFACE && logMessage "Using non-WiFi interface $INTERFACE"
IPADDRESS=`ifconfig "$INTERFACE" | sed -n 's|.*inet \([^ ]*\) .*|\1|p'`

if $ROOT; then
	[ -z "$INTERFACE" ] &&
		STATEFILE='/var/run/WLANderlust.state' ||
		STATEFILE="/var/run/WLANderlust.$INTERFACE.state"
else
	[ -z "$INTERFACE" ] &&
		STATEFILE=~/'.WLANderlust.state' ||
		STATEFILE=~/".WLANderlust.$INTERFACE.state"
fi

# Load the network state
readState()
{
	# Load the state file
	[ -z "$STATE" ] && [ -f "$STATEFILE" ] &&
		STATE=`cat "$STATEFILE"`
}
readState

# $1 key
getState()
{
	readState

	# Lookup key value in the configuration
	sed -n "s|^$1=['\"]\?\([^'\"]*\)['\"]\?$|\1|p" <<< "$STATE" | tail -n 1
}

# $1 key
# $2 value
setState()
{
	readState

	# Check if state key is already set
	if [ -z "$STATE" ]; then
		STATE="$1='${@:2}'"
	elif grep -q "^$1=" <<< "$STATE"; then
		# If configuration key is set, update value
		# Escape for sed special characters
		_KEY=`sed -e 's/[]\/$*.^[]/\\\&/g' <<< "$1"`
		_VALUE=`sed -e 's/[\/&]/\\\&/g' <<< "${@:2}"`
		STATE=`sed "s/^\($_KEY\)=.*$/\1='$_VALUE'/" <<< "$STATE"`
	else
		# If configuration key is not set, add new key with value
		STATE+="
$1='${@:2}'"
	fi
	#ToDo Probably need to do some escapeing here too
	eval "$1='${@:2}'"
}

storeState()
{
	#$DEBUGLOGGING && logMessage "$STATE"
	[ -z "$STATE" ] &&
		return

	if [ ! -f "$STATEFILE" ]; then
		touch "$STATEFILE" &&
			echo "$STATE" > "$STATEFILE" ||
			logError "Can't write to status file"
	else
		# Check if new the state changes from the old state by comparing the MD5 sums
		OLDMD5=`md5sum "$STATEFILE" | awk '{ print $1 }'`
		NEWMD5=`md5sum <<< "$STATE" | awk '{ print $1 }'`
		if [ "$OLDMD5" != "$NEWMD5" ]; then
			# The MD5 sum differences, we're dealing with a new state, update the state
			# Store new state
			touch "$STATEFILE" &&
				echo "$STATE" > "$STATEFILE" ||
				logError "Can't write to status file"
		fi
	fi
}

# Helper functions
readPassword() {
	unset PASSWORD
	if $SHOWPASSWORDS; then
		read -r -p "$1" -e -i "$2" PASSWORD
	else
		# Code example from https://stackoverflow.com/questions/4316730/linux-scripting-hiding-user-input-on-terminal
		#ToDo Backspace doesn't work yet
		echo -n "$1"
		while IFS= read -r -s -n 1 _C; do
			if [[ -z "$_C" ]]; then
				echo
				break
			else
				echo -n '*'
				PASSWORD+="$_C"
			fi
		done
	fi
}

# HTTP related functions
expandLocation()
{
	# Check if it starts with a protocol
	if grep -iq "^[a-z]*://" <<< "$1"; then
		echo "$1"
	elif grep -q '^/' <<< "$1"; then
		echo -n "$2" | sed 's|\(^[a-zA-Z]*://[^/]*\)/.*|\1|'; echo "$1"
	else
		echo -n "$2" | sed 's|\(^.*/\).*|\1|'; echo "$1"
	fi
}

# Tries to fiend a location redirect in a given HTML + headers.
# First it ries toe fiend a Location header
# Then a refresh meta tag
# Then a window.location string, this is very crude
getLocationHeader()
{
	LOCATION=''
	if LOCATION=`echo "$1" | tr -d '\r' | sed -n 's|^Location: \(.*\)$|\1|Ip'` && [ ! -z "$LOCATION" ]; then
		# We found a Location header
		$VERBOSELOGGING && logMessage "Location header found: \"$LOCATION\""
	elif LOCATION=`echo "$1" | tr -d '\r\n' | sed -n 's|.*\<meta http-equiv="refresh" [^>]*content="[^;]*; *url=\([^"]*\)".*|\1|Ip'` && [ ! -z "$LOCATION" ]; then
		# We found a refresh meta tag
		$VERBOSELOGGING && logMessage "Refresh meta tag found: \"$LOCATION\""
	elif LOCATION=`echo "$1" | sed -n 's|.* window\.location=["'\'']\([^"'\'']*\)["'\''].*|\1|Ip' | head -n 1` && [ ! -z "$LOCATION" ]; then
		# we found a JavaScript redirect
		$VERBOSELOGGING && logMessage "JavaScript redirect found: \"$LOCATION\""
	else
		$VERBOSELOGGING && logMessage 'No location found'
	fi

	if [ ! -z "$LOCATION" ]; then
		LOCATION=`expandLocation "$LOCATION" "$2"`
		$VERBOSELOGGING && logMessage "Location expanded to: \"$LOCATION\""
	fi
}

BODYLOGFILECOUNTER=1
curlGet()
{
	[ -z "$1" ] &&
		logError 'No location given' &&
		return 1
	LOCATION="$1"

	# Create Cookie Jar if not exists
	#[ ! -f "$COOKIEJAR" ] && touch "$COOKIEJAR"

	#CURLARGUMENTS=(--raw -4)
	CURLARGUMENTS=(-4)
	[ ! -z "$INTERFACE" ] && CURLARGUMENTS+=(--interface "$INTERFACE")
	[ ! -z "$TIMEOUT" ] && CURLARGUMENTS+=(-m "$TIMEOUT")
	[ -r "$COOKIEJAR" ] && CURLARGUMENTS+=(--cookie "$COOKIEJAR")
	[ -f "$COOKIEJAR" ] && [ -w "$COOKIEJAR" ] && CURLARGUMENTS+=(--cookie-jar "$COOKIEJAR")
	[ ! -f "$COOKIEJAR" ] && [ -w `dirname "$COOKIEJAR"` ] && CURLARGUMENTS+=(--cookie-jar "$COOKIEJAR")
	[ ! -z "$LASTLOCATION" ] && CURLARGUMENTS+=(--referer "$LASTLOCATION")
	CURLARGUMENTS+=(-s -i "$LOCATION")
	$DEBUGLOGGING && logMessage curl "${CURLARGUMENTS[@]}"

	$VERBOSELOGGING && logMessage "Retrieving \"$LOCATION\""
	if BODY=`curl "${CURLARGUMENTS[@]}"`; then
		if $CAPTIVEPORTALLOGGING; then
			BODYLOGFILE="$CAPTIVEPORTALLOGPATH/CaptivePortal$TIMESTAMP-$BODYLOGFILECOUNTER.log"
			echo "BSSID $BSSID" > "$BODYLOGFILE"
			echo "SSID $SSID" >> "$BODYLOGFILE"
			echo "curl ${CURLARGUMENTS[@]}" >> "$BODYLOGFILE"
			echo "GET $LOCATION" >> "$BODYLOGFILE"
			echo -n "$BODY" >> "$BODYLOGFILE"
			$VERBOSELOGGING && logMessage "Body logged in \"$BODYLOGFILE\""
		fi
		BODYLOGFILECOUNTER=$(($BODYLOGFILECOUNTER + 1))
		return 0;
	fi
	logError "Failed to retrieve '$LOCATION'"
	return 1
}

curlPost()
{
	[ -z "$1" ] &&
		logError 'No location given' &&
		return 1
	[ -z "$2" ] &&
		logError 'No post data given' &&
		return 1
	LOCATION="$1"
	POSTDATA="$2"

	# Create Cookie Jar if not exists
	#[ ! -f "$COOKIEJAR" ] && touch "$COOKIEJAR"

	#CURLARGUMENTS=(--raw -4)
	CURLARGUMENTS=(-4)
	[ ! -z "$INTERFACE" ] && CURLARGUMENTS+=(--interface "$INTERFACE")
	[ ! -z "$TIMEOUT" ] && CURLARGUMENTS+=(-m "$TIMEOUT")
	[ -r "$COOKIEJAR" ] && CURLARGUMENTS+=(--cookie "$COOKIEJAR")
	[ -f "$COOKIEJAR" ] && [ -w "$COOKIEJAR" ] && CURLARGUMENTS+=(--cookie-jar "$COOKIEJAR")
	[ ! -f "$COOKIEJAR" ] && [ -w `dirname "$COOKIEJAR"` ] && CURLARGUMENTS+=(--cookie-jar "$COOKIEJAR")
	[ ! -z "$LASTLOCATION" ] && CURLARGUMENTS+=(-H "Origin: `echo "$LASTLOCATION" | sed 's|^\([a-z]*://[^/]*\)/.*$|\1|'`" --referer "$LASTLOCATION")
	CURLARGUMENTS+=(-s -i -H 'Content-Type: application/x-www-form-urlencoded' --data "$POSTDATA" "$LOCATION")
	$DEBUGLOGGING && logMessage curl "${CURLARGUMENTS[@]}"

	$VERBOSELOGGING && logMessage "Posting \"$LOCATION\""
	if BODY=`curl "${CURLARGUMENTS[@]}"`; then
		if $CAPTIVEPORTALLOGGING; then
			BODYLOGFILE="$CAPTIVEPORTALLOGPATH/CaptivePortal$TIMESTAMP-$BODYLOGFILECOUNTER.log"
			echo "BSSID $BSSID" > "$BODYLOGFILE"
			echo "SSID $SSID" >> "$BODYLOGFILE"
			echo "curl ${CURLARGUMENTS[@]}" >> "$BODYLOGFILE"
			echo "GET $LOCATION" >> "$BODYLOGFILE"
			echo -n "$BODY" >> "$BODYLOGFILE"
			$VERBOSELOGGING && logMessage "Body logged in \"$BODYLOGFILE\""
		fi
		BODYLOGFILECOUNTER=$(($BODYLOGFILECOUNTER + 1))
		return 0;
	fi
	logError "Failed to retrieve '$LOCATION'"
	return 1
}

getBody()
{
	LOCATION="$1"
	if curlGet "$LOCATION"; then
		LASTLOCATION="$LOCATION"
		if [ "$2" = 'true' ]; then
			getLocationHeader "$BODY" "$LOCATION"
			while [ ! -z "$LOCATION" ] && [ $BODYLOGFILECOUNTER -lt 15 ]; do
				if curlGet "$LOCATION"; then
					LASTLOCATION="$LOCATION"
					getLocationHeader "$BODY" "$LOCATION"
				else
					BODY=''
					LOCATION=''
				fi
			done
			LOCATION="$LASTLOCATION"
		fi
	else
		BODY=''
	fi
}

# Captive Portal functions
# https://en.wikipedia.org/wiki/Captive_portal
# Returns 0 when Captive Portal is present else 1
isCaptivePortalPresent()
{
	(! $INTERFACEISUP || ! $ISWIFIINTERFACE || [ "$WPASTATE" != 'COMPLETED' ]) &&
		return 1

	SCRIPTNAME="$LIBPATH/captiveportal"
	. "$SCRIPTNAME" STATE
	SCRIPTNAME="$0"

	if [ ! -z "$WHATISMYIPURL" ] && ([ "$CAPTIVEPORTALTYPE" = 'none' ] || [ "$CAPTIVEPORTALSTATE" = 'solved' ]); then
		setState 'EXTERNALIPADDRESS' `curl -4 --interface "$INTERFACE" -m "$TIMEOUT" -s "$WHATISMYIPURL" | grep '^[0-9.]*$'`
	fi

	[ "$CAPTIVEPORTALSTATE" = 'present' ] &&
		return 0
	return 1
}

# Returns 0 when Captive Portal is none or solved else 1
solveCaptivePortal()
{
	(! $INTERFACEISUP || ! $ISWIFIINTERFACE || [ "$WPASTATE" != 'COMPLETED' ]) &&
		return 1

	SCRIPTNAME="$LIBPATH/captiveportal"
	. "$SCRIPTNAME" SOLVE
	SCRIPTNAME="$0"

	if [ ! -z "$WHATISMYIPURL" ] && ([ "$CAPTIVEPORTALTYPE" = 'none' ] || [ "$CAPTIVEPORTALSTATE" = 'solved' ]); then
		setState 'EXTERNALIPADDRESS' `curl -4 --interface "$INTERFACE" -m "$TIMEOUT" -s "$WHATISMYIPURL" | grep '^[0-9.]*$'`
	fi

	([ "$CAPTIVEPORTALTYPE" = 'none' ] || [ "$CAPTIVEPORTALSTATE" = 'solved' ]) &&
		return 0
	return 1
}

# WiFi functions
getWiFiStatus()
{
	PREVIOUSBSSID=`getState 'BSSID'`

	IFCONFIG=`ifconfig "$INTERFACE"`
	grep -q '<UP' <<< "$IFCONFIG" &&
		INTERFACEISUP='true' ||
		INTERFACEISUP='false'

	#ToDo make this portable
	if $INTERFACEISUP && $ISWIFIINTERFACE && [ "`uname`" = 'Linux' ]  &&
		[ -x '/sbin/wpa_cli' ] && WPASTATUS=`/sbin/wpa_cli -i "$INTERFACE" status 2> /dev/null`; then
		setState 'BSSID' `sed -n 's|^bssid=\(.*\)$|\1|p' <<< "$WPASTATUS"`
		setState 'SSID' `sed -n 's|^ssid=\(.*\)$|\1|p' <<< "$WPASTATUS"`
		setState 'WPASTATE' `sed -n 's|^wpa_state=\(.*\)$|\1|p' <<< "$WPASTATUS"`
		KEYMGMT=`sed -n 's|^key_mgmt=\(.*\)$|\1|p' <<< "$WPASTATUS"`

		if [ -x '/sbin/iw' ]; then
			CHANNEL=`/sbin/iw dev $INTERFACE info | sed -n 's|^.*channel \([0-9]\+\) .*$|\1|p'`
			# Get the signal strength of the current connection
			SIGNALSTRENGTH=`/sbin/iw dev $INTERFACE link | sed -n 's|^.*signal: \(.*\) dBm|\1|p'`
		fi

		ISROAMING='false'
		if [ -f "/etc/network/interfaces.d/$INTERFACE" ]; then
			WPASUPPLICANTCONF=`sed -n 's/^\swpa-\(conf\|roam\) \(.*\)/\2/p' "/etc/network/interfaces.d/$INTERFACE"`
			# Are we in roaming mode?
			grep -q '^\swpa-roam ' "/etc/network/interfaces.d/$INTERFACE" && ISROAMING='true'
		fi
	elif $INTERFACEISUP && $ISWIFIINTERFACE && [ "`uname`" = 'Darwin' ]; then
		_AIRPORT=`/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport en0 -I`
		setState 'BSSID' `sed -n 's|^[[:space:]]*BSSID: ||p' <<< "$_AIRPORT"`
		setState 'SSID' `sed -n 's|^[[:space:]]*SSID: ||p' <<< "$_AIRPORT"`
		setState 'WPASTATE' ''
		[ ! -z "$SSID" ] &&
			setState 'WPASTATE' 'COMPLETED'
	else
		setState 'BSSID' ''
		setState 'SSID' ''
		setState 'WPASTATE' ''
	fi

	storeState
}

showWiFiStatus()
{
	if $INTERFACEISUP && $ISWIFIINTERFACE; then
		# Print some details
		if $INTERACTIVE || $VERBOSELOGGING || [ "$PREVIOUSBSSID" != "$BSSID" ]; then
			if [ "$WPASTATE" = 'COMPLETED' ]; then
				MESSAGE="WiFi interface $INTERFACE ($MACADDRESS) is connected to \"$SSID\" ($BSSID)"
				[ "$KEYMGMT" = 'NONE' ] &&
					MESSAGE+=", no encryption" ||
					MESSAGE+=", $KEYMGMT encryption"
				MESSAGE+=", channel $CHANNEL, signal $SIGNALSTRENGTH dBm"
				$ISROAMING &&
					MESSAGE+=", roaming" ||
					MESSAGE+=", not roaming"
				logMessage "$MESSAGE"
			else
				MESSAGE="WiFi interface $INTERFACE ($MACADDRESS) is not connected to an Access Point, $WPASTATE"
				$ISROAMING &&
					MESSAGE+=", roaming" ||
					MESSAGE+=", not roaming"
				logError "$MESSAGE"
			fi
		fi
	fi
}


stopDHClient()
{
	if [ -f "/run/dhclient.$INTERFACE.pid" ]; then
		/sbin/dhclient -x -pf "/run/dhclient.$INTERFACE.pid" > /dev/null 2>&1
	fi
	killall dhclient > /dev/null 2>&1
	rm "/var/lib/dhcp/dhclient.$INTERFACE.leases" > /dev/null 2>&1
	rm "/var/lib/dhcp/dhclient6.$INTERFACE.leases" > /dev/null 2>&1
}

startDHClient()
{
	/sbin/dhclient -nw -4 -v -pf "/run/dhclient.$INTERFACE.pid" -lf "/var/lib/dhcp/dhclient.$INTERFACE.leases" -I -df "/var/lib/dhcp/dhclient6.$INTERFACE.leases" "$INTERFACE" > /dev/null 2>&1
}

[ -z "$WHATISMYIPURL" ] && WHATISMYIPURL=`getConfigValue 'WHATISMYIPURL'`
getNetworkStatus()
{
	[ "`uname`" = 'Linux' ] &&
		setState 'DEFAULTROUTEINTERFACE' `route -n | sed -n 's|^0\.0\.0\.0 .* \([^ ]*\)$|\1|p'`
	[ "`uname`" = 'Darwin' ] &&
		setState 'DEFAULTROUTEINTERFACE' `netstat -nr | grep '^default' | awk '{ print $6 }'`

	IFCONFIG=`ifconfig "$INTERFACE"`
	grep -q '<UP' <<< "$IFCONFIG" &&
		INTERFACEISUP='true' ||
		INTERFACEISUP='false'
	MACADDRESS=`sed -n 's|^[[:space:]]*ether \([a-z0-9:]*\) .*$|\1|p' <<< "$IFCONFIG"`

	if ! $INTERFACEISUP; then
		# Interface is down
		setState 'IPADDRESS' ''
		setState 'NETMASK' ''
		setState 'GATEWAY' ''
		setState 'EXTERNALIPADDRESS' ''
	elif $ISWIFIINTERFACE && [ "$WPASTATE" != 'COMPLETED' ]; then
		# WiFi is not connected
		setState 'IPADDRESS' ''
		setState 'NETMASK' ''
		setState 'GATEWAY' ''
		setState 'EXTERNALIPADDRESS' ''
	elif ! $ISWIFIINTERFACE || [ "$WPASTATE" = 'COMPLETED' ]; then
		setState 'IPADDRESS' `sed -n 's|.*inet \([^ ]*\) .*|\1|p' <<< "$IFCONFIG"`
		setState 'NETMASK' `sed -n 's|.*netmask \([^ ]*\) .*|\1|p' <<< "$IFCONFIG"`
		setState 'GATEWAY' `route -n | sed -n "s|[0-9.]* *\([0-9.]*\) .* $INTERFACE|\1|p" | grep -v "0\.0\.0\.0" | uniq`
	fi

	storeState
}

showNetworkStatus()
{
	if ! $INTERFACEISUP; then
		logError "Interface $INTERFACE is down"
	elif $INTERACTIVE || $VERBOSELOGGING || [ "$PREVIOUSBSSID" != "$BSSID" ]; then
		# Print some details
		if (! $ISWIFIINTERFACE || [ "$WPASTATE" = 'COMPLETED' ]) && [ -n "$IPADDRESS" ]; then
			MESSAGE=''
			MESSAGE+="IP address: $IPADDRESS, netmask: $NETMASK"
			[ ! -z "$GATEWAY" ] &&
				MESSAGE+=", gateway: $GATEWAY"
			[ ! -z "$EXTERNALIPADDRESS" ] && [ "$IPOVERDNSSTATE" = 'stopped' ] && [ "$VPNSTATE" = 'stopped' ] &&
				MESSAGE+=", external IP address: $EXTERNALIPADDRESS"
			logMessage "$MESSAGE"

			# IP over DNS tunneling
			if [ "$IPOVERDNSSTATE" = 'started' ]; then
				MESSAGE="IP over DNS tunnel is active using interface $IPOVERDNSINTERFACE, server: $IPOVERDNSSERVER, mode: $IPOVERDNSMODE"
				MESSAGE+=" , IP address: $IPOVERDNSIPADDRESS, netmask: $IPOVERDNSNETMASK"
				[ ! -z "$IPOVERDNSGATEWAY" ] &&
					MESSAGE+=", gateway: $IPOVERDNSGATEWAY"
				[ ! -z "$EXTERNALIPADDRESS" ] && [ "$VPNSTATE" = 'stopped' ] &&
					MESSAGE+=", external IP address: $EXTERNALIPADDRESS"
				logMessage "$MESSAGE"
			elif [ "$IPOVERDNSSTATE" = 'stopped' ]; then
				$VERBOSELOGGING &&
					logMessage 'IP over DNS tunnel is not active'
			else
				logMessage 'IP over DNS tunnel error'
			fi

			# VPN
			if [ "$VPNSTATE" = 'started' ]; then
				MESSAGE="VPN type $VPNNAME is active using interface $VPNINTERFACE, server: $VPNSERVERHOSTNAME, IP address: $VPNIPADDRESS, netmask: $VPNNETMASK"
				[ ! -z "$VPNGATEWAY" ] &&
					MESSAGE+=", gateway: $VPNGATEWAY"
				[ ! -z "$EXTERNALIPADDRESS" ] &&
					MESSAGE+=", external IP address: $EXTERNALIPADDRESS"
				logMessage "$MESSAGE"
			elif [ "$VPNSTATE" = 'stopped' ]; then
				$VERBOSELOGGING &&
					logMessage 'VPN is not active'
			else
				logMessage 'VPN error'
			fi
		else
			logError "Interface $INTERFACE is not connected"
		fi

		# Host Access Pont
		if [ "$HOSTAPSTATE" = 'started' ]; then
			MESSAGE="Host Access Point $HOSTAPINTERFACE ($HOSTAPBSSID) \"$HOSTAPSSID\", channel: $HOSTAPCHANNEL, $HOSTAPTXPOWER dBm"
			MESSAGE+=", IP address: $HOSTAPIPADDRESS, netmask: $HOSTAPNETMASK"
			logMessage "$MESSAGE"
		else
			$VERBOSELOGGING &&
				logMessage 'Host Access Point not active'
		fi
	fi
}

scanForNetworks()
{
	! $INTERFACEISUP &&
		return 1

	echo -n 'Scanning'
	while ! IWLISTSCAN=`iwlist "$INTERFACE" scan 2> /dev/null`; do
		echo -n '.'
		sleep 1
	done

	WIFIINFO=`grep -B 5 -A 4 'ESSID:' <<< "$IWLISTSCAN" | sed 's|^  \s*|  |'`
	# Escape for sed special characters
	_HOSTAPSSID=`sed -e 's/[]\/$*.^[]/\\\&/g' <<< "$HOSTAPSSID"`
	WIFIINFO=`tac <<< "$WIFIINFO" | sed -n "/Mode:Master/I,+10 p" | grep -A 5 'ESSID:' | sed "/ESSID:\"$_HOSTAPSSID\"/I,+6 d" | tac`

	[ -z "$WIFIINFO" ] &&
		echo ' - No WiFi networks found' ||
		echo
}

reassociateInterface()
{
	! $ISWIFIINTERFACE &&
		return 1
	[ "$WPASTATE" != 'COMPLETED' ] &&
		return 1
	[ -n "$EXTERNALIPADDRESS" ] &&
		return 1
	# Don't reassociate when last time was less then 2 minutes ago
	LASTREASSOCIATED=`getState 'LASTREASSOCIATED'`
	[ -n "$LASTREASSOCIATED" ] && [ $LASTREASSOCIATED -gt $((`date +%s` - 120)) ] &&
		return 1
	setState 'LASTREASSOCIATED' `date +%s`
	storeState

	logMessage 'Reassociating...'
	! $ISROAMING && stopDHClient
	wpa_cli -i "$INTERFACE" reassociate > /dev/null 2>&1
	! $ISROAMING && startDHClient
}

append2WPAsupplicant()
{
	if [ ! -f "$WPASUPPLICANTCONF" ]; then
		logError "$WPASUPPLICANTCONF does not exist"
		return 1
	elif [ ! -w "$WPASUPPLICANTCONF" ]; then
		logError "$WPASUPPLICANTCONF is not writable"
		return 1
	elif [ "$WPASTATE" != 'COMPLETED' ]; then
		return 1
	elif [ "$KEYMGMT" != 'NONE' ]; then
		return 1
	elif /bin/grep -q "$BSSID" "$WPASUPPLICANTCONF"; then
		# BSSID is already mentioned in wpa_supplicant configuration
		return 0
	elif /bin/grep -q "^[^#]\s*\bssid=\"$SSID\"" "$WPASUPPLICANTCONF"; then
		# SSID is already configured in wpa_supplicant configuration
		return 0
	elif [ -z "$EXTERNALIPADDRESS" ] && [ "$SIGNALSTRENGTH" -lt 60 ]; then
		# Connection is to poor to say anything about the workings of the connection
		return 1
	fi

	if ([ "$CAPTIVEPORTALTYPE" = 'none' ] || [ "$CAPTIVEPORTALSTATE" = 'solved' ]) && [ ! -z "$EXTERNALIPADDRESS" ]; then
		_PRIORITY='50'
	elif [ "$CAPTIVEPORTALSTATE" = 'present' ]; then
		_PRIORITY='-50'
	else
		_PRIORITY='-200'
	fi

	logMessage "Appending configuration for SSID \"$SSID\" to $WPASUPPLICANTCONF"
	cat << EOF >> "$WPASUPPLICANTCONF"

# Added on `date` by WLANderlust
network={
	bssid=$BSSID
	ssid="$SSID"
	key_mgmt=NONE
	priority=$_PRIORITY
}
EOF

	# Reload the wpa_supplicant configuration
	$VERBOSELOGGING && logMessage 'Reload the wpa_supplicant configuration'
	/sbin/wpa_cli -i "$INTERFACE" reconfigure
	$VERBOSELOGGING && logMessage 'Wpa_supplicant configuration reloaded'
}

editwpa_supplicant()
{
	if [ ! -f "$WPASUPPLICANTCONF" ]; then
		logError "$WPASUPPLICANTCONF does not exist"
		return 1
	elif [ ! -w "$WPASUPPLICANTCONF" ]; then
		logError "$WPASUPPLICANTCONF is not writable"
		return 1
	fi

	if [ ! -f ~/.selected_editor ]; then
		/usr/bin/select-editor
	fi
	. ~/.selected_editor

	OLDMD5=`md5sum "$WPASUPPLICANTCONF" | awk '{ print $1 }'`
	"$SELECTED_EDITOR" "$WPASUPPLICANTCONF"
	NEWMD5=`md5sum "$WPASUPPLICANTCONF" | awk '{ print $1 }'`

	[ "$OLDMD5" = "$NEWMD5" ] &&
		return 0

	# Reload the wpa_supplicant configuration if the file has changed
	$VERBOSELOGGING && logMessage 'Reload the wpa_supplicant configuration'
	/sbin/wpa_cli -i "$INTERFACE" reconfigure
	$VERBOSELOGGING && logMessage 'Wpa_supplicant configuration reloaded'
}

configureWiFi()
{
	_SSID="$1"
	SSIDINFO="$2"

	# Check if this network is already in wpa_supplicant
	if /bin/fgrep -q -x "   ssid=\"$_SSID\"" "$WPASUPPLICANTCONF"; then
		OLDWIFICONFIG=`sudo fgrep -B 1 -A 3 -x "    ssid=\"$_SSID\"" "$WPASUPPLICANTCONF"`

		echo 'SSID already configured:'
		echo "$OLDWIFICONFIG"
		echo
		echo 'Replace/Delete/Quit? (R/D/Q)'
		read -r -n 1 CHOICE
		case "$CHOICE" in
			D|d)
				logError 'Delete configuration not yet implemented'
				return 1
			;;
			Q|q) return 1 ;;
		esac
	fi

	if [ ! -z "$_SSID" ]; then
		if [ -z "$SSIDINFO" ]; then
			readPassword 'Password: '
			echo
		elif echo -n "$SSIDINFO" | grep -q "^  Encryption key:on$"; then
			unset PASSWORD
			# Check password length, 8 to 63 charactrs
			while ! echo -n "$PASSWORD"| egrep -q "^.{8,63}$"; do
				readPassword 'Password: ' "$PASSWORD"
			done
			echo
		fi

		if [ ! -z "$PASSWORD" ]; then
			WIFICONFIG="network={
	#bssid=$BSSID
	ssid=\"$_SSID\"
	psk=\"$PASSWORD\"
	priority=50
}"
		else
			WIFICONFIG="network={
	#bssid=$BSSID
	ssid=\"$_SSID\"
	key_mgmt=NONE
	priority=50
}"
		fi

		# Check if this network is already in wpa_supplicant
		#if ! /bin/fgrep -q -x " ssid=\"$_SSID\"" "$WPASUPPLICANTCONF"; then
		if ! /bin/grep -q "^\s*ssid=\"$_SSID\"" "$WPASUPPLICANTCONF"; then
			while true; do
				echo 'Configuration:'
				echo "$WIFICONFIG"
				echo
				echo 'Save? (Y/n/e)'
				read -r -n 1 CHOICE
				case "$CHOICE" in
					''|Y|y)
						echo -e "\n# Added on `date` by WLANderlust" >> "$WPASUPPLICANTCONF"
						echo "$WIFICONFIG" >> "$WPASUPPLICANTCONF"
						logMessage 'Configuration stored'

						$ROAMING || stopDHClient
						# Reload the wpa_supplicant configuration
						wpa_cli -i $INTERFACE reconfigure > /dev/null
						$ROAMING || startDHClient
						return 0
						;;
					E|e)
						TEMPFILE=`tempfile`
						echo "$WIFICONFIG" > "$TEMPFILE"
						if [ ! -f ~/.selected_editor ]; then
							/usr/bin/select-editor
						fi
						. ~/.selected_editor
						"$SELECTED_EDITOR" "$TEMPFILE"
						WIFICONFIG=`cat "$TEMPFILE"`
						rm "$TEMPFILE"
						;;
					N|n)
						logError 'Configuration not stored'
						return 1
						;;
				esac
			done
		else
			echo 'New configuration:'
			echo "$WIFICONFIG"
			echo
			echo 'Save? (y/N)'
			read -n 1 CHOICE
			case "$CHOICE" in
				Y|y)
					logError 'Replace configuration not yet implemented'
					return 1
					;;
				*)
					logError 'New configuration not stored'
					return 1
					;;
			esac
		fi
	fi

	return 1
}

configureWiFiManual()
{
	read -r -p 'SSID: ' _SSID
	configureWiFi "$_SSID" ''
}

toggleRoaming()
{
	! $ISWIFIINTERFACE &&
		return 1
	[ ! -f "/etc/network/interfaces.d/$INTERFACE" ] &&
		return 1

	if $ISROAMING; then
		# Disable roaming
		wpa_action "$INTERFACE" stop > /dev/null 2>&1
		ifdown "$INTERFACE" > /dev/null 2>&1
		INTERFACECONFIG=`sed 's| inet manual| inet dhcp|;s|wpa-roam |wpa-conf |' "/etc/network/interfaces.d/$INTERFACE"`
		echo "$INTERFACECONFIG" > "/etc/network/interfaces.d/$INTERFACE"
		ifup "$INTERFACE" > /dev/null 2>&1 &
		ISROAMING='false'
	else
		# Enable roaming
		ifdown "$INTERFACE" > /dev/null 2>&1
		INTERFACECONFIG=`sed 's| inet dhcp| inet manual|;s|wpa-conf |wpa-roam |' "/etc/network/interfaces.d/$INTERFACE"`
		echo "$INTERFACECONFIG" > "/etc/network/interfaces.d/$INTERFACE"
		ifup "$INTERFACE" > /dev/null 2>&1 &
		ISROAMING='true'
	fi
}

# IP over DNS tunneling functions
isIPoverDNSactive()
{
	[ "`uname`" != 'Linux' ] &&
		return

	SCRIPTNAME="$LIBPATH/ipoverdns"
	. "$SCRIPTNAME" STATE
	SCRIPTNAME="$0"

	if [ ! -z "$WHATISMYIPURL" ] && [ "$IPOVERDNSSTATE" = 'started' ]; then
		setState 'EXTERNALIPADDRESS' `curl -4 --interface "$IPOVERDNSINTERFACE" -m "$TIMEOUT" -s "$WHATISMYIPURL" | grep '^[0-9.]*$'`
	fi
}
isIPoverDNSactive

startIPoverDNStunneling()
{
	[ "`uname`" != 'Linux' ] &&
		return

	SCRIPTNAME="$LIBPATH/ipoverdns"
	. "$SCRIPTNAME" START
	SCRIPTNAME="$0"

	if [ ! -z "$WHATISMYIPURL" ] && [ "$IPOVERDNSSTATE" = 'started' ]; then
		setState 'EXTERNALIPADDRESS' `curl -4 --interface "$IPOVERDNSINTERFACE" -m "$TIMEOUT" -s "$WHATISMYIPURL" | grep '^[0-9.]*$'`
	fi
}

stopIPoverDNStunneling()
{
	[ "`uname`" != 'Linux' ] &&
		return

	SCRIPTNAME="$LIBPATH/ipoverdns"
	. "$SCRIPTNAME" STOP
	SCRIPTNAME="$0"
}

# VPN functions
isVPNactive()
{
	[ "`uname`" != 'Linux' ] &&
		return

	SCRIPTNAME="$LIBPATH/vpn"
	. "$SCRIPTNAME" STATE
	SCRIPTNAME="$0"

	if [ ! -z "$WHATISMYIPURL" ] && [ "$VPNSTATE" = 'started' ]; then
		setState 'EXTERNALIPADDRESS' `curl -4 --interface "$VPNINTERFACE" -m "$TIMEOUT" -s "$WHATISMYIPURL" | grep '^[0-9.]*$'`
	fi
}
isVPNactive

startVPN()
{
	[ "`uname`" != 'Linux' ] &&
		return

	SCRIPTNAME="$LIBPATH/vpn"
	. "$SCRIPTNAME" START
	SCRIPTNAME="$0"

	if [ ! -z "$WHATISMYIPURL" ] && [ "$VPNSTATE" = 'started' ]; then
		setState 'EXTERNALIPADDRESS' `curl -4 --interface "$VPNINTERFACE" -m "$TIMEOUT" -s "$WHATISMYIPURL" | grep '^[0-9.]*$'`
	fi
}

stopVPN()
{
	[ "`uname`" != 'Linux' ] &&
		return

	SCRIPTNAME="$LIBPATH/vpn"
	. "$SCRIPTNAME" STOP
	SCRIPTNAME="$0"
}

# Firewall functions
startFirewall()
{
	FWINTERFACE="$INTERFACE"
	if [ "$IPOVERDNSSTATE" = 'started' ]; then
		FWINTERFACE="$IPOVERDNSINTERFACE"
	elif [ "$VPNSTATE" = 'started' ]; then
		FWINTERFACE="$VPNINTERFACE"
	else
		FWINTERFACE="$INTERFACE"
	fi

	for FILE in $(run-parts --list "$LIBPATH/firewall.d"); do
		SCRIPTNAME="$FILE"
		. "$FILE" START
	done
	SCRIPTNAME="$0"
}

stopFirewall()
{
	$VERBOSELOGGING && logMessage 'Stopping Firewall'

	for FILE in $(run-parts --list --reverse "$LIBPATH/firewall.d"); do
		SCRIPTNAME="$FILE"
		. "$FILE" STOP
	done
	SCRIPTNAME="$0"

	FWINTERFACE="$INTERFACE"
	logMessage 'Firewall stopped'
}

# Changes the channel of the Host Access Point
switchHostAPchannel()
{
	[ ! -f '/etc/hostapd/hostapd.conf' ] &&
		return 1
	[ -z "$CHANNEL" ] &&
		return 0

	NEWHOSTAPCHANNEL=1
	[ "$CHANNEL" -lt 6 ] && NEWHOSTAPCHANNEL=11

	if [ "$NEWHOSTAPCHANNEL" -ne "$HOSTAPCHANNEL" ]; then
		logMessage "Changing channel of the Host Access Point to $NEWHOSTAPCHANNEL"
		# Change channel in hostapd.conf
		sed "s|^channel=.*$|channel=$NEWHOSTAPCHANNEL|" -i /etc/hostapd/hostapd.conf
		# restart hostapd
		# Somehow `service hostapd restart` does not start the service
		service hostapd stop
		service hostapd start
		return 0
	fi

	return 1
}

getGPSStatus()
{
	LATITUDE=''
	LONGITUDE=''
	_GPSSENTENCE=`gpspipe -n 2 -w | grep -m 1 '"DEVICES"'`
	_GPSDEVICES=`sed -n 's/.*"devices":\[\([^]]*\)].*/\1/p' <<< "$_GPSSENTENCE"`
	if [ -n "$_GPSDEVICES" ]; then
		logMessage 'GPS active'
		_GPSSENTENCE=`timeout $TIMEOUT gpspipe -w | grep -m 1 '"TPV"'`
		LATITUDE=`sed -n 's/.*"lat":\([0-9.]*\).*/\1/p' <<< "$_GPSSENTENCE"`
		LONGITUDE=`sed -n 's/.*"lon":\([0-9.]*\).*/\1/p' <<< "$_GPSSENTENCE"`
	fi
}

showGPSStatus()
{
	echo "$LATITUDE,$LONGITUDE"
}

# User interaction
WLANderlustConfigurationMenu()
{
	while true; do
		! $VERBOSELOGGING && clear
		echo -e '\x1B[1mWLANderlust'
		echo -e '\x1B[2mNot all those who WLANder have lost connection\x1B[0m'
		echo 'Configuration Menu'
		echo
		echo -e "  \x1B[1mW\x1B[0m Edit "`sed 's|^\([^Ww]*\)\([Ww]\)\(.*\)$|\1\\\\x1B[1m\2\\\\x1B[0m\3|' <<< "$WPASUPPLICANTCONF"`
		echo -e '  \x1B[1mC\x1B[0m Configure \x1B[1mC\x1B[0maptive Portal'
		echo -e '  \x1B[1mD\x1B[0m Configure IP over \x1B[1mD\x1B[0mNS tunneling'
		echo -e '  \x1B[1mV\x1B[0m Configure \x1B[1mV\x1B[0mPN'
		$ISWIFIINTERFACE && $ISROAMING &&
			echo -e '  \x1B[1mR\x1B[0m Disable \x1B[1mr\x1B[0moaming'
		$ISWIFIINTERFACE && ! $ISROAMING &&
			echo -e '  \x1B[1mR\x1B[0m Enable \x1B[1mR\x1B[0moaming'
		$SHOWPASSWORDS &&
			echo -e '  \x1B[1mP\x1B[0m Hide \x1B[1mP\x1B[0masswords' ||
			echo -e '  \x1B[1mP\x1B[0m Show \x1B[1mP\x1B[0masswords'
		echo -e '  \x1B[1mB\x1B[0m \x1B[1mB\x1B[0mack to main menu'
		echo -e '  \x1B[1mQ\x1B[0m \x1B[1mQ\x1B[0muit'
		echo

		# Flush stdin
		read -d '' -t 0.1 -n 10000 IGNORE
		if read -r -p 'Option: '; then
			case "$REPLY" in
				W|w) editwpa_supplicant ;;
				C|c) . "$LIBPATH/captiveportal" CONFIGURE ;;
				D|d) . "$LIBPATH/ipoverdns" CONFIGURE ;;
				V|v) . "$LIBPATH/vpn" CONFIGURE ;;
				R|r) toggleRoaming ;;
				P|p)
					$SHOWPASSWORDS &&
						SHOWPASSWORDS='false' ||
						SHOWPASSWORDS='true'
					setConfigValue 'SHOWPASSWORDS' "$SHOWPASSWORDS"
					storeConfig
					;;
				B|b) break ;;
				Q|q|X|x) exit ;;
			esac
		fi
	done
}

WLANderlustMenu()
{
	SCANFORNETWORKS='false'
	while true; do
		TIMESTAMP=`date +%Y%m%d%H%M%S`
		BODYLOGFILECOUNTER='1'
		getGPSStatus
		getWiFiStatus
		getNetworkStatus
		! $VERBOSELOGGING && clear
		echo -e '\x1B[1mWLANderlust'
		echo -e '\x1B[2mNot all those who WLANder have lost connection\x1B[0m'
		showWiFiStatus
		isCaptivePortalPresent
		showNetworkStatus
		showGPSStatus
		echo

		$INTERFACEISUP &&
			$ISWIFIINTERFACE &&
			([ "$WPASTATE" != 'COMPLETED' ] || [ -z "$EXTERNALIPADDRESS" ]) &&
			SCANFORNETWORKS='true'
		$SCANFORNETWORKS &&
			scanForNetworks &&
			echo
		if $SCANFORNETWORKS && [ ! -z "$WIFIINFO" ]; then
			mapfile -t SSIDS < <(sed -n 's|^  ESSID:"\(.*\)"|\1|p' <<<  "$WIFIINFO" | sort -bf | uniq)
			for I in ${!SSIDS[@]}; do
				_SSID=${SSIDS[$I]}
				SSIDINFO=`fgrep -B 5 "ESSID:\"$_SSID\"" <<< "$WIFIINFO"`
				_CHANNEL=`sed -n 's|^  Channel:||p' <<< "$SSIDINFO" | head -n 1`
				# Calculate signal quality
				QUALITY=$(( 100 * `echo "$SSIDINFO" | grep "^  Quality=" | sed 's|.*Quality=\([0-9]*/[0-9]*\)  Signal level=-[0-9]* dBm.*|\1|' | sort | tail -n 1` ))

				#
				if [ "$WPASTATE" = 'COMPLETED' ] && [ "$_SSID" = "$SSID" ]; then
					echo -n "âœ”ï¸Ž"
				else
					echo -n ' '
				fi

				printf '\x1B[1m%2d\x1B[0m' $I

				# Print a floppy character if the SSID is already configured in the WPA supplicant configuration
				grep -q "^\sssid=\"$_SSID\"" "$WPASUPPLICANTCONF" &&
					echo -n "ðŸ’¾" ||
					echo -n ' '

				# Print a lock character if encryption is on
				grep -q "^  Encryption key:on$" <<< "$SSIDINFO" &&
					echo -n "ðŸ”’" ||
					echo -n ' '

				#for FILE in `ls /home/pi/Instabridge/*.dib`; do
				# sqlite3 $FILE 'select "'$FILE'", `ssid`, quote(`security.password`), `location.latitude`, `location.longitude` from hotspots where `ssid` like "'"$_SSID"'" COLLATE NOCASE'
				#done

				printf '%3d%% %2d "%s"' $QUALITY $_CHANNEL "$_SSID"

				echo
			done
		fi
		$SCANFORNETWORKS &&
			echo -e '  \x1B[1mM\x1B[0m \x1B[1mM\x1B[0manual'

		$SCANFORNETWORKS &&
			echo -e '  \x1B[1mW\x1B[0m Stop scanning for W\x1B[0miFi networks' ||
			echo -e '  \x1B[1mW\x1B[0m Scan for \x1B[1mW\x1B[0miFi networks'
		$SCANFORNETWORKS &&
			[ "$WPASTATE" = 'COMPLETED' ] &&
			echo -e "  \x1B[1mA\x1B[0m Re\x1B[1ma\x1B[0mssociate interface $INTERFACE"
		(! $ISWIFIINTERFACE || [ "$WPASTATE" = 'COMPLETED' ]) &&
			[ "$CAPTIVEPORTALSTATE" != 'none' ] &&
			[ "$CAPTIVEPORTALSTATE" != 'solved' ] &&
			echo -e '  \x1B[1mS\x1B[0m \x1B[1mS\x1B[0molve Captive Portal'
		(! $ISWIFIINTERFACE || [ "$WPASTATE" = 'COMPLETED' ]) &&
			(([ "$CAPTIVEPORTALSTATE" != 'none' ] && [ "$CAPTIVEPORTALSTATE" != 'solved' ]) || $FORCE) &&
			[ "$IPOVERDNSSTATE" = 'stopped' ] &&
			[ "$VPNSTATE" = 'stopped' ] &&
			echo -e '  \x1B[1mD\x1B[0m Start IP over \x1B[1mD\x1B[0mNS tunneling'
		[ "$IPOVERDNSSTATE" != 'stopped' ] && [ "$VPNSTATE" = 'stopped' ] &&
			echo -e '  \x1B[1mD\x1B[0m Stop IP over \x1B[1mD\x1B[0mNS tunneling'
		(! $ISWIFIINTERFACE || [ "$WPASTATE" = 'COMPLETED' ]) &&
			([ "$CAPTIVEPORTALSTATE" = 'none' ] || [ "$CAPTIVEPORTALSTATE" = 'solved' ]) &&
			[ "$VPNSTATE" = 'stopped' ] &&
			echo -e '  \x1B[1mV\x1B[0m Start \x1B[1mV\x1B[0mPN'
		[ "$VPNSTATE" != 'stopped' ] && echo -e '  \x1B[1mV\x1B[0m Stop \x1B[1mV\x1B[0mPN'
		echo -e '  \x1B[1mC\x1B[0m \x1B[1mC\x1B[0monfigure WLANderlust'
		echo -e '  \x1B[1mQ\x1B[0m \x1B[1mQ\x1B[0muit'
		echo

		# Flush stdin
		read -d '' -t 0.1 -n 10000 IGNORE

		if $SCANFORNETWORKS; then
			read -r -p 'Network to configure or option: ' -t 30
		else
			read -r -p 'Option: '
		fi
			case "$REPLY" in
				W|w)
					$SCANFORNETWORKS &&
						SCANFORNETWORKS='false' ||
						SCANFORNETWORKS='true'
					;;
				A|a)
					reassociateInterface
					;;
				S|s)
					solveCaptivePortal
					append2WPAsupplicant
					;;
				D|d)
					echo
					if [ "$IPOVERDNSSTATE" = 'stopped' ]; then
						startIPoverDNStunneling
						stopFirewall
						startFirewall
					else
						stopIPoverDNStunneling
						stopFirewall
						startFirewall
					fi
					;;
				V|v)
					echo
					if [ "$VPNSTATE" = 'stopped' ]; then
						startVPN
						stopFirewall
						startFirewall
					else
						stopVPN
						stopFirewall
						startFirewall
					fi
					;;
				Q|q|X|x) exit ;;
				C|c)
					WLANderlustConfigurationMenu
					;;
				M|m)
					configureWiFiManual
					;;
				'') ;;
				*)
					if $SCANFORNETWORKS && echo -n "$REPLY" | egrep -q "^[0-9]+$" && [ ! -z "${SSIDS[$REPLY]}" ]; then
						echo
						_SSID="${SSIDS[$REPLY]}"
						echo "SSID: $_SSID"
						SSIDINFO=`echo -n "$WIFIINFO" | fgrep -B 5 "  ESSID:\"$_SSID\""`
						configureWiFi "$_SSID" "$SSIDINFO"
					else
						echo -en '\t\x1B[1m\x1B[31mInvalid input\x1B[0m\r'
					fi
					;;
			esac

		storeState
	done
}

if $INTERACTIVE && ! $STATUS; then
	if $ROOT; then
		WLANderlustMenu
	else
		getWiFiStatus
		getNetworkStatus
		echo -e '\x1B[1mWLANderlust'
		echo -e '\x1B[2mNot all those who WLANder have lost connection\x1B[0m'
		showWiFiStatus
		isCaptivePortalPresent
		showNetworkStatus
		echo

		if (! $ISWIFIINTERFACE || [ "$WPASTATE" = 'COMPLETED' ]) &&
			[ "$CAPTIVEPORTALSTATE" != 'none' ] &&
			[ "$CAPTIVEPORTALSTATE" != 'solved' ] &&
			$SOLVE; then
			solveCaptivePortal
			storeState
		fi

		[ "`uname`" = 'Linux' ] &&
			echo 'Run as root for more options'
	fi
else
		if $ROOT; then
			$STOPFIREWALL && stopFirewall
			$STOPVPN && stopVPN
			$STOPIPOVERDNS && stopIPoverDNStunneling
			getWiFiStatus
			getNetworkStatus
			showWiFiStatus
			isCaptivePortalPresent
			$SOLVE && solveCaptivePortal
			$REASSOCIATE && reassociateInterface
			$STARTIPOVERDNS && startIPoverDNStunneling
			$STARTVPN && startVPN
			$STARTFIREWALL && startFirewall
			$SWITCHHOSTAPCHANNEL && switchHostAPchannel
			$APPEND2WPASUPPLICANT && append2WPAsupplicant
		else
			getWiFiStatus
			getNetworkStatus
			showWiFiStatus
			isCaptivePortalPresent
			$SOLVE && solveCaptivePortal
		fi
		showNetworkStatus
	storeState
fi
