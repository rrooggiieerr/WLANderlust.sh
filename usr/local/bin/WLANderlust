#!/bin/bash
#
# WLANderlust
#
# Rogier van Staveren, January 2019, initial release
# Februaty 2019, moved most functions to a seperate core library file

usage()
{
	# Are we root?
	if [ "$(id -u)" -eq 0 ]; then
		echo -e '\x1B[1mWLANderlust
\x1B[2mNot all those who WLANder have lost connection\x1B[0m

Usage:
  -h, --help
  -i, --interface [interface]
  -s, --solve
  --startIPoverDNS	Starts IP over DNS tunneling if Captive Portal could not be solved
  --stopIPoverDNS	Stops IP over DNS tunneling
  --force		Forces IP over DNS tunneling if connection is not obstructed
  --startVPN		Starts VPN if IP over DNS tunnel is not active
  --VPNtype [type]	Sets the type of VPN to use
  --stopVPN		Stops VPN
  --startFirewall
  --stopFirewall
  --restartFirewall
  --reassociate
  --switchHostAPchannel
  --append2WPAsupplicant
  --status
  --verbose
  --debug'
  	else
	  	echo -e '\x1B[1mWLANderlust
\x1B[2mNot all those who WLANder have lost connection\x1B[0m

Usage:
  -h, --help
  -i, --interface [interface]
  -s, --solve
  --status
  --verbose
  --debug

Run as root for more options'
	fi
}

# Handle arguments
SOLVE='false'
STARTIPOVERDNS='false'
STOPIPOVERDNS='false'
FORCE='false'
STARTVPN='false'
STOPVPN='false'
STARTFIREWALL='false'
STOPFIREWALL='false'
REASSOCIATE='false'
SWITCHHOSTAPCHANNEL='false'
APPEND2WPASUPPLICANT='false'
STATUS='false'
while [ ! -z "$1" ]; do
	PARAM=`tr '[:upper:]' '[:lower:]' <<< "$1"`
	# Are we root?
	if [ "$(id -u)" -eq 0 ]; then
		case $PARAM in
			-h|--help) usage; exit ;;
			-i|--interface) INTERFACE="$2"; shift ;;
			-s|--solve) INTERACTIVE='false'; SOLVE='true' ;;
			--startipoverdns|--startipoverdnstunneling) INTERACTIVE='false'; STARTIPOVERDNS='true' ;;
			--stopipoverdns|--stopIPoverdnstunneling) INTERACTIVE='false'; STOPIPOVERDNS='true' ;;
			--force) FORCE='true' ;;
			--startvpn) INTERACTIVE='false'; STARTVPN='true' ;;
			--vpntype) VPNTYPE="$2"; shift ;;
			--stopvpn) INTERACTIVE='false'; STOPVPN='true' ;;
			--startfirewall) INTERACTIVE='false'; STARTFIREWALL='true' ;;
			--stopfirewall) INTERACTIVE='false'; STOPFIREWALL='true' ;;
			--restartfirewall) INTERACTIVE='false'; STOPFIREWALL='true'; STARTFIREWALL='true' ;;
			--reassociate) INTERACTIVE='false'; REASSOCIATE='true' ;;
			--switchhostapchannel) INTERACTIVE='false'; SWITCHHOSTAPCHANNEL='true' ;;
			--append2wpasupplicant) INTERACTIVE='false'; APPEND2WPASUPPLICANT='true' ;;
			--state|--status) STATUS='true' ;;
			--verbose) VERBOSELOGGING='true' ;;
			--debug) DEBUGLOGGING='true' ;;
			*)
				logError "invalid parameter \"$PARAM\""
				usage
				exit
				;;
		esac
	else
		case $PARAM in
			-h|--help) usage; exit ;;
			-i|--interface) INTERFACE="$2"; shift ;;
			-s|--solve) SOLVE='true' ;;
			--state|--status) STATUS='true' ;;
			--verbose) VERBOSELOGGING='true' ;;
			--debug) DEBUGLOGGING='true' ;;
			*)
				logError "invalid parameter \"$PARAM\""
				usage
				exit
				;;
		esac
	fi
	shift
done

MYDIR="${BASH_SOURCE%/*}"
[[ ! -d "$MYDIR" ]] && MYDIR="$PWD"
DEFAULTLIBPATH="$(realpath "$MYDIR/../lib/WLANderlust/")"
[ -z "$LIBPATH" ] && LIBPATH="$DEFAULTLIBPATH"

SCRIPTNAME="$LIBPATH/core"
. "$SCRIPTNAME"
SCRIPTNAME="$0"

$DEBUGLOGGING && logMessage 'Debug logging enabled'
$VERBOSELOGGING && logMessage 'Verbose logging enabled'
$DEBUGLOGGING && logMessage "Interactive mode: $INTERACTIVE"
$DEBUGLOGGING && echo "LIBPATH=$LIBPATH"

# If no interface is given try to figure out which interface to use
if [ -z "$INTERFACE" ] && [ ! -z "$DEFAULTROUTEINTERFACE" ] && [ "$DEFAULTROUTEINTERFACE" != "$HOSTAPINTERFACE" ]; then
	INTERFACE="$DEFAULTROUTEINTERFACE"
	logMessage "No network interface defined, using default route interface $DEFAULTROUTEINTERFACE"
elif [ -z "$INTERFACE" ]; then
	logMessage 'No network interface defined, detecting network interface'
	INTERFACE=`ifconfig | sed -n 's|^\([a-z]*[0-9]*\):.*|\1|p' | sed "/lo/d;/tun[0-9]*/d;/dns[0-9]*/d;/$HOSTAPINTERFACE/d"`
	if [ -z "$INTERFACE" ]; then
		INTERFACE=`ifconfig -a | sed -n 's|^\([a-z]*[0-9]*\):.*|\1|p' | sed "/lo/d;/tun[0-9]*/d;/dns[0-9]*/d;/$HOSTAPINTERFACE/d"`
	fi

	if [ -z "$INTERFACE" ]; then
		logError 'Unable to detect your network interface'
		logError 'Please define a network interface with the --interface [interface] parameter'
		exit 1
	fi

	# Check if only one interface is returned
	if [ "`wc -l <<< "$INTERFACE"`" -gt 1 ]; then
		$DEBUGLOGGING && echo "$INTERFACE"
		logError 'Unable to detect your network interface'
		logError 'Please define a network interface with the --interface [interface] parameter'
		exit 1
	fi
fi

if ! IFCONFIG=`ifconfig "$INTERFACE" 2> /dev/null`; then
	logError "Interface $INTERFACE does not exist"
	exit 1
fi

grep -q '<UP' <<< "$IFCONFIG" &&
	INTERFACEISUP='true' ||
	INTERFACEISUP='false'
$DEBUGLOGGING && $INTERFACEISUP && logMessage "Interface $INTERFACE is up"
$DEBUGLOGGING && ! $INTERFACEISUP && logMessage "Interface $INTERFACE is down"

ISWIFIINTERFACE='false'
[ "`uname`" = 'Linux' ] && grep -q '^wlan[0-9]*$' <<< "$INTERFACE" && ISWIFIINTERFACE='true'
[ "`uname`" = 'Darwin' ]  &&
	networksetup -listallhardwareports | grep -B 1 "^Device: $INTERFACE" | grep -q "Hardware Port: Wi-Fi" &&
	ISWIFIINTERFACE='true'
$VERBOSELOGGING && $ISWIFIINTERFACE && logMessage "Using WiFi interface $INTERFACE"
$VERBOSELOGGING && ! $ISWIFIINTERFACE && logMessage "Using non-WiFi interface $INTERFACE"
IPADDRESS=`ifconfig "$INTERFACE" | sed -n 's|.*inet \([^ ]*\) .*|\1|p'`

if $ROOT; then
	[ -z "$INTERFACE" ] &&
		STATEFILE='/var/run/WLANderlust.state' ||
		STATEFILE="/var/run/WLANderlust.$INTERFACE.state"
else
	[ -z "$INTERFACE" ] &&
		STATEFILE=~/'.WLANderlust.state' ||
		STATEFILE=~/".WLANderlust.$INTERFACE.state"
fi

# Load the network state
readState

showWiFiStatus()
{
	if $INTERFACEISUP && $ISWIFIINTERFACE; then
		# Print some details
		if $INTERACTIVE || $VERBOSELOGGING || [ "$PREVIOUSBSSID" != "$BSSID" ]; then
			if [ "$WPASTATE" = 'COMPLETED' ]; then
				MESSAGE="WiFi interface $INTERFACE ($MACADDRESS) is connected to \"$SSID\" ($BSSID)"
				[ "$KEYMGMT" = 'NONE' ] &&
					MESSAGE+=", no encryption" ||
					MESSAGE+=", $KEYMGMT encryption"
				MESSAGE+=", channel $CHANNEL, signal $SIGNALSTRENGTH dBm"
				$ISROAMING &&
					MESSAGE+=", roaming" ||
					MESSAGE+=", not roaming"
				logMessage "$MESSAGE"
			else
				MESSAGE="WiFi interface $INTERFACE ($MACADDRESS) is not connected to an Access Point, $WPASTATE"
				$ISROAMING &&
					MESSAGE+=", roaming" ||
					MESSAGE+=", not roaming"
				logError "$MESSAGE"
			fi
		fi
	fi
}


showNetworkStatus()
{
	if ! $INTERFACEISUP; then
		logError "Interface $INTERFACE is down"
	elif $INTERACTIVE || $VERBOSELOGGING || [ "$PREVIOUSBSSID" != "$BSSID" ]; then
		# Print some details
		if (! $ISWIFIINTERFACE || [ "$WPASTATE" = 'COMPLETED' ]) && [ -n "$IPADDRESS" ]; then
			MESSAGE=''
			MESSAGE+="IP address: $IPADDRESS, netmask: $NETMASK"
			[ ! -z "$GATEWAY" ] &&
				MESSAGE+=", gateway: $GATEWAY"
			[ ! -z "$EXTERNALIPADDRESS" ] && [ "$IPOVERDNSSTATE" = 'stopped' ] && [ "$VPNSTATE" = 'stopped' ] &&
				MESSAGE+=", external IP address: $EXTERNALIPADDRESS"
			logMessage "$MESSAGE"

			# IP over DNS tunneling
			if [ "$IPOVERDNSSTATE" = 'started' ]; then
				MESSAGE="IP over DNS tunnel is active using interface $IPOVERDNSINTERFACE, server: $IPOVERDNSSERVER, mode: $IPOVERDNSMODE"
				MESSAGE+=" , IP address: $IPOVERDNSIPADDRESS, netmask: $IPOVERDNSNETMASK"
				[ ! -z "$IPOVERDNSGATEWAY" ] &&
					MESSAGE+=", gateway: $IPOVERDNSGATEWAY"
				[ ! -z "$EXTERNALIPADDRESS" ] && [ "$VPNSTATE" = 'stopped' ] &&
					MESSAGE+=", external IP address: $EXTERNALIPADDRESS"
				logMessage "$MESSAGE"
			elif [ "$IPOVERDNSSTATE" = 'stopped' ]; then
				$VERBOSELOGGING &&
					logMessage 'IP over DNS tunnel is not active'
			else
				logMessage 'IP over DNS tunnel error'
			fi

			# VPN
			if [ "$VPNSTATE" = 'started' ]; then
				MESSAGE="VPN type $VPNNAME is active using interface $VPNINTERFACE, server: $VPNSERVERHOSTNAME, IP address: $VPNIPADDRESS, netmask: $VPNNETMASK"
				[ ! -z "$VPNGATEWAY" ] &&
					MESSAGE+=", gateway: $VPNGATEWAY"
				[ ! -z "$EXTERNALIPADDRESS" ] &&
					MESSAGE+=", external IP address: $EXTERNALIPADDRESS"
				logMessage "$MESSAGE"
			elif [ "$VPNSTATE" = 'stopped' ]; then
				$VERBOSELOGGING &&
					logMessage 'VPN is not active'
			else
				logMessage 'VPN error'
			fi
		else
			logError "Interface $INTERFACE is not connected"
		fi

		# Host Access Pont
		if [ "$HOSTAPSTATE" = 'started' ]; then
			MESSAGE="Host Access Point $HOSTAPINTERFACE ($HOSTAPBSSID) \"$HOSTAPSSID\", channel: $HOSTAPCHANNEL, $HOSTAPTXPOWER dBm"
			MESSAGE+=", IP address: $HOSTAPIPADDRESS, netmask: $HOSTAPNETMASK"
			logMessage "$MESSAGE"
		else
			$VERBOSELOGGING &&
				logMessage 'Host Access Point not active'
		fi
	fi
}

isIPoverDNSactive
isVPNactive

showGPSStatus()
{
	$HASGPS &&
		echo "Location: $LATITUDE,$LONGITUDE Altitude: $ALTITUDE Speed: $SPEED"
}

# User interaction
WLANderlustConfigurationMenu()
{
	while true; do
		! $VERBOSELOGGING && clear
		echo -e '\x1B[1mWLANderlust'
		echo -e '\x1B[2mNot all those who WLANder have lost connection\x1B[0m'
		echo 'Configuration Menu'
		echo
		echo -e "  \x1B[1mW\x1B[0m Edit "`sed 's|^\([^Ww]*\)\([Ww]\)\(.*\)$|\1\\\\x1B[1m\2\\\\x1B[0m\3|' <<< "$WPASUPPLICANTCONF"`
		echo -e '  \x1B[1mC\x1B[0m Configure \x1B[1mC\x1B[0maptive Portal'
		echo -e '  \x1B[1mD\x1B[0m Configure IP over \x1B[1mD\x1B[0mNS tunneling'
		echo -e '  \x1B[1mV\x1B[0m Configure \x1B[1mV\x1B[0mPN'
		$ISWIFIINTERFACE && $ISROAMING &&
			echo -e '  \x1B[1mR\x1B[0m Disable \x1B[1mr\x1B[0moaming'
		$ISWIFIINTERFACE && ! $ISROAMING &&
			echo -e '  \x1B[1mR\x1B[0m Enable \x1B[1mR\x1B[0moaming'
		$SHOWPASSWORDS &&
			echo -e '  \x1B[1mP\x1B[0m Hide \x1B[1mP\x1B[0masswords' ||
			echo -e '  \x1B[1mP\x1B[0m Show \x1B[1mP\x1B[0masswords'
		echo -e '  \x1B[1mB\x1B[0m \x1B[1mB\x1B[0mack to main menu'
		echo -e '  \x1B[1mQ\x1B[0m \x1B[1mQ\x1B[0muit'
		echo

		# Flush stdin
		read -d '' -t 0.1 -n 10000 IGNORE
		if read -r -p 'Option: '; then
			case "$REPLY" in
				W|w) editwpa_supplicant ;;
				C|c) . "$LIBPATH/captiveportal" CONFIGURE ;;
				D|d) . "$LIBPATH/ipoverdns" CONFIGURE ;;
				V|v) . "$LIBPATH/vpn" CONFIGURE ;;
				R|r) toggleRoaming ;;
				P|p)
					$SHOWPASSWORDS &&
						SHOWPASSWORDS='false' ||
						SHOWPASSWORDS='true'
					setConfigValue 'SHOWPASSWORDS' "$SHOWPASSWORDS"
					storeConfig
					;;
				B|b) break ;;
				Q|q|X|x) exit ;;
			esac
		fi
	done
}

WLANderlustMenu()
{
	SCANFORNETWORKS='false'
	while true; do
		TIMESTAMP=`date +%Y%m%d%H%M%S`
		BODYLOGFILECOUNTER='1'
		getGPSStatus
		getWiFiStatus
		getNetworkStatus
		! $VERBOSELOGGING && clear
		echo -e '\x1B[1mWLANderlust'
		echo -e '\x1B[2mNot all those who WLANder have lost connection\x1B[0m'
		showWiFiStatus
		isCaptivePortalPresent
		showNetworkStatus
		showGPSStatus
		echo

		$INTERFACEISUP &&
			$ISWIFIINTERFACE &&
			([ "$WPASTATE" != 'COMPLETED' ] || [ -z "$EXTERNALIPADDRESS" ]) &&
			SCANFORNETWORKS='true'
		$SCANFORNETWORKS &&
			scanForNetworks &&
			echo
		if $SCANFORNETWORKS && [ ! -z "$WIFIINFO" ]; then
			mapfile -t SSIDS < <(sed -n 's|^  ESSID:"\(.*\)"|\1|p' <<<  "$WIFIINFO" | sort -bf | uniq)
			for I in ${!SSIDS[@]}; do
				_SSID=${SSIDS[$I]}
				SSIDINFO=`fgrep -B 5 "ESSID:\"$_SSID\"" <<< "$WIFIINFO"`
				_CHANNEL=`sed -n 's|^  Channel:||p' <<< "$SSIDINFO" | head -n 1`
				# Calculate signal quality
				QUALITY=$(( 100 * `echo "$SSIDINFO" | grep "^  Quality=" | sed 's|.*Quality=\([0-9]*/[0-9]*\)  Signal level=-[0-9]* dBm.*|\1|' | sort | tail -n 1` ))

				#
				if [ "$WPASTATE" = 'COMPLETED' ] && [ "$_SSID" = "$SSID" ]; then
					echo -n "âœ”ï¸Ž"
				else
					echo -n ' '
				fi

				printf '\x1B[1m%2d\x1B[0m' $I

				# Print a floppy character if the SSID is already configured in the WPA supplicant configuration
				grep -q "^\sssid=\"$_SSID\"" "$WPASUPPLICANTCONF" &&
					echo -n "ðŸ’¾" ||
					echo -n ' '

				# Print a lock character if encryption is on
				grep -q "^  Encryption key:on$" <<< "$SSIDINFO" &&
					echo -n "ðŸ”’" ||
					echo -n ' '

				#for FILE in `ls /home/pi/Instabridge/*.dib`; do
				# sqlite3 $FILE 'select "'$FILE'", `ssid`, quote(`security.password`), `location.latitude`, `location.longitude` from hotspots where `ssid` like "'"$_SSID"'" COLLATE NOCASE'
				#done

				printf '%3d%% %2d "%s"' $QUALITY $_CHANNEL "$_SSID"

				echo
			done
		fi
		$SCANFORNETWORKS &&
			echo -e '  \x1B[1mM\x1B[0m \x1B[1mM\x1B[0manual'

		$SCANFORNETWORKS &&
			echo -e '  \x1B[1mW\x1B[0m Stop scanning for W\x1B[0miFi networks' ||
			echo -e '  \x1B[1mW\x1B[0m Scan for \x1B[1mW\x1B[0miFi networks'
		$SCANFORNETWORKS &&
			[ "$WPASTATE" = 'COMPLETED' ] &&
			echo -e "  \x1B[1mA\x1B[0m Re\x1B[1ma\x1B[0mssociate interface $INTERFACE"
		(! $ISWIFIINTERFACE || [ "$WPASTATE" = 'COMPLETED' ]) &&
			[ "$CAPTIVEPORTALSTATE" != 'none' ] &&
			[ "$CAPTIVEPORTALSTATE" != 'solved' ] &&
			echo -e '  \x1B[1mS\x1B[0m \x1B[1mS\x1B[0molve Captive Portal'
		(! $ISWIFIINTERFACE || [ "$WPASTATE" = 'COMPLETED' ]) &&
			(([ "$CAPTIVEPORTALSTATE" != 'none' ] && [ "$CAPTIVEPORTALSTATE" != 'solved' ]) || $FORCE) &&
			[ "$IPOVERDNSSTATE" = 'stopped' ] &&
			[ "$VPNSTATE" = 'stopped' ] &&
			echo -e '  \x1B[1mD\x1B[0m Start IP over \x1B[1mD\x1B[0mNS tunneling'
		[ "$IPOVERDNSSTATE" != 'stopped' ] && [ "$VPNSTATE" = 'stopped' ] &&
			echo -e '  \x1B[1mD\x1B[0m Stop IP over \x1B[1mD\x1B[0mNS tunneling'
		(! $ISWIFIINTERFACE || [ "$WPASTATE" = 'COMPLETED' ]) &&
			([ "$CAPTIVEPORTALSTATE" = 'none' ] || [ "$CAPTIVEPORTALSTATE" = 'solved' ]) &&
			[ "$VPNSTATE" = 'stopped' ] &&
			echo -e '  \x1B[1mV\x1B[0m Start \x1B[1mV\x1B[0mPN'
		[ "$VPNSTATE" != 'stopped' ] && echo -e '  \x1B[1mV\x1B[0m Stop \x1B[1mV\x1B[0mPN'
		echo -e '  \x1B[1mC\x1B[0m \x1B[1mC\x1B[0monfigure WLANderlust'
		echo -e '  \x1B[1mQ\x1B[0m \x1B[1mQ\x1B[0muit'
		echo

		# Flush stdin
		read -d '' -t 0.1 -n 10000 IGNORE

		if $SCANFORNETWORKS; then
			read -r -p 'Network to configure or option: ' -t 30
		else
			read -r -p 'Option: '
		fi
			case "$REPLY" in
				W|w)
					$SCANFORNETWORKS &&
						SCANFORNETWORKS='false' ||
						SCANFORNETWORKS='true'
					;;
				A|a)
					reassociateInterface
					;;
				S|s)
					solveCaptivePortal
					append2WPAsupplicant
					;;
				D|d)
					echo
					if [ "$IPOVERDNSSTATE" = 'stopped' ]; then
						startIPoverDNStunneling
						#stopFirewall
						#startFirewall
					else
						stopIPoverDNStunneling
						#stopFirewall
						#startFirewall
					fi
					;;
				V|v)
					echo
					if [ "$VPNSTATE" = 'stopped' ]; then
						startVPN
						stopFirewall
						startFirewall
					else
						stopVPN
						stopFirewall
						startFirewall
					fi
					;;
				Q|q|X|x) exit ;;
				C|c)
					WLANderlustConfigurationMenu
					;;
				M|m)
					configureWiFiManual
					;;
				'') ;;
				*)
					if $SCANFORNETWORKS && echo -n "$REPLY" | egrep -q "^[0-9]+$" && [ ! -z "${SSIDS[$REPLY]}" ]; then
						echo
						_SSID="${SSIDS[$REPLY]}"
						echo "SSID: $_SSID"
						SSIDINFO=`echo -n "$WIFIINFO" | fgrep -B 5 "  ESSID:\"$_SSID\""`
						configureWiFi "$_SSID" "$SSIDINFO"
					else
						echo -en '\t\x1B[1m\x1B[31mInvalid input\x1B[0m\r'
					fi
					;;
			esac

		storeState
	done
}

if $INTERACTIVE && ! $STATUS; then
	if $ROOT; then
		WLANderlustMenu
	else
		getWiFiStatus
		getNetworkStatus
		echo -e '\x1B[1mWLANderlust'
		echo -e '\x1B[2mNot all those who WLANder have lost connection\x1B[0m'
		showWiFiStatus
		isCaptivePortalPresent
		showNetworkStatus
		echo

		if (! $ISWIFIINTERFACE || [ "$WPASTATE" = 'COMPLETED' ]) &&
			[ "$CAPTIVEPORTALSTATE" != 'none' ] &&
			[ "$CAPTIVEPORTALSTATE" != 'solved' ] &&
			$SOLVE; then
			solveCaptivePortal
			storeState
		fi

		[ "`uname`" = 'Linux' ] &&
			echo 'Run as root for more options'
	fi
else
		if $ROOT; then
			$STOPFIREWALL && stopFirewall
			$STOPVPN && stopVPN
			$STOPIPOVERDNS && stopIPoverDNStunneling
			getWiFiStatus
			getNetworkStatus
			showWiFiStatus
			isCaptivePortalPresent
			$SOLVE && solveCaptivePortal
			$REASSOCIATE && reassociateInterface
			$STARTIPOVERDNS && startIPoverDNStunneling
			$STARTVPN && startVPN
			$STARTFIREWALL && startFirewall
			$SWITCHHOSTAPCHANNEL && switchHostAPchannel
			$APPEND2WPASUPPLICANT && append2WPAsupplicant
		else
			getWiFiStatus
			getNetworkStatus
			showWiFiStatus
			isCaptivePortalPresent
			$SOLVE && solveCaptivePortal
		fi
		showNetworkStatus
	storeState
fi
